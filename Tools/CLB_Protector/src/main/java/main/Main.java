package main;

import java.io.*;
import java.math.BigInteger;
import java.util.*;
import models.*;
import org.apache.commons.cli.*;
import utils.Helper;

public class Main {

    private static Map<String, Object> parseArgv(String[] argv) {
        HelpFormatter formatter = new HelpFormatter();
        Map<String, Object> args = new HashMap<>();
        Options options = new Options();

        Option inputOption = new Option("i", "input", true, "The elf input file");
        inputOption.setRequired(true);
        options.addOption(inputOption);

        Option encryptionDetailsOption = new Option("ed", "encryption-details", true, "The encryption details file generated by the CLB Injector");
        encryptionDetailsOption.setRequired(true);
        options.addOption(encryptionDetailsOption);

        Option otherDetailsOption = new Option("od", "other-details", true, "The other details file generated by the CLB Injector");
        otherDetailsOption.setRequired(true);
        options.addOption(otherDetailsOption);

        // check for help
        if(Arrays.stream(argv).anyMatch("--help"::equals) || Arrays.stream(argv).anyMatch("-h"::equals)) {
            formatter.printHelp("utility-name", options);
            System.exit(0);
        }

        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = null;

        try {
            cmd = parser.parse(options, argv);
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            formatter.printHelp("CLB Protector", options);
            System.exit(1);
        }

        args.put("input", cmd.getOptionValue(inputOption.getOpt()));
        args.put("integrityInfosFile", cmd.getOptionValue(encryptionDetailsOption.getOpt()));
        args.put("hexPlaceholdersFile", cmd.getOptionValue(otherDetailsOption.getOpt()));

        return args;
    }

    public static void main(String[] argv) throws Exception {
        // parse args
        Map<String, Object> args = parseArgv(argv);
        String elf = (String) args.get("input");
        String integrityInfosFile = (String) args.get("integrityInfosFile");
        String hexPlaceholdersFile = (String) args.get("hexPlaceholdersFile");

        // Get array of offset-size
        ProtectionOffset textSection = null;
        ProtectionOffset relocateSection = null;
        List<ProtectionOffset> protectionOffsets = new ArrayList<>();

        ProcessBuilder pb = new ProcessBuilder("readelf", "-S", elf);
        Process p = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line = null;
        while ((line = reader.readLine()) != null) {
            try {
                if (line.contains("] .text ")) {
                    textSection = new ProtectionOffset(line);
                } else if (line.contains("] .relocate ")) { // or .stack or .bss
                    relocateSection = new ProtectionOffset(line);
                    // protectionOffsets.add(new ProtectionOffset(line));
                } /*else if (line.contains("] .stack ")) {
                    protectionOffsets.add(new ProtectionOffset(line));
                }*/
            } catch (CustomException e) {
                System.err.println("Error parsing ELF sections. Message: " + e.getMessage());
            }
        }
        assert textSection != null;
        assert relocateSection != null;

        // Get symbol's information from nm linux command
        pb = new ProcessBuilder("nm", "-S", "-l", "--numeric-sort", "--defined-only", elf);
        p = pb.start();
        reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
        List<Symbol> symbols = new LinkedList<>();
        line = null;
        while ((line = reader.readLine()) != null) {
            Symbol sym = null;
            if (symbols.size() > 0 && line.trim().split("\\s+")[1].equals("t") && symbols.get(symbols.size()-1).firstDataOffset == null) {
                if (Integer.parseInt(line.trim().split("\\s+")[0], 16) < relocateSection.addr) {
                    symbols.get(symbols.size()-1).firstDataOffset = Integer.parseInt(line.trim().split("\\s+")[0], 16) - textSection.addr + textSection.offset;
                } else {
                    symbols.get(symbols.size()-1).firstDataOffset = Integer.parseInt(line.trim().split("\\s+")[0], 16) - relocateSection.addr + relocateSection.offset;
                }
            } else {
                try {
                    sym = new Symbol(line, textSection.addr, textSection.offset, relocateSection.addr, relocateSection.offset);
                } catch (CustomException e) {
                    System.err.println("Ignoring non source symbols");
                    continue;
                }

                symbols.add(sym);
            }
        }

        // Access to file with read and write permissions
        RandomAccessFile randomAccessFile = new RandomAccessFile(new File(elf), "rw");

        // Read elf bytes
        byte[] elfBytes = new byte[Math.toIntExact(randomAccessFile.length())];
        randomAccessFile.read(elfBytes);
        randomAccessFile.seek(0);

        int numberOfProtectedFunctionInElf = 0;
        int numberOfProtectedFunctionNotInElf = 0;

        List<Symbol> newSymbols = new ArrayList<>();

        // Substitute all values in original function -> We use them for the integrity check
        //  -- fix the length of the method to decode
        List<HexPlaceholder> hexPlaceholders = Helper.readFile(hexPlaceholdersFile, HexPlaceholder.class);
        for (HexPlaceholder hexPlaceholder : hexPlaceholders) {
            Symbol originSymbol = null;
            Symbol newSymbol = null;
            try {
                originSymbol = getSymbolFromList(symbols, hexPlaceholder.getSource_file(), hexPlaceholder.getOriginal_function_name());
                newSymbol = getSymbolFromList(symbols, hexPlaceholder.getSource_file(), hexPlaceholder.getNew_function_name());
                numberOfProtectedFunctionInElf++;
                newSymbols.add(newSymbol);
                newSymbols.sort(new Comparator<Symbol>() {
                    @Override
                    public int compare(Symbol s1, Symbol s2) {
                        return s1.offset - s2.offset;
                    }
                });
            } catch (NoSuchElementException e) {
                System.err.println(e.getMessage());
                numberOfProtectedFunctionNotInElf++;
                continue;
            }

            byte[] originFunctionBytes = new byte[originSymbol.length];
            randomAccessFile.seek(originSymbol.offset);
            randomAccessFile.read(originFunctionBytes, 0, originSymbol.length);

            String unsignedOriginalBytesString = Helper.getUnsignedBytesString(originFunctionBytes);
            int lengthOffset = (unsignedOriginalBytesString.indexOf(hexPlaceholder.getHex_to_replace()) / 2);
            if (lengthOffset == 0) {
                continue;
            }

            // newSymbol.length
            byte[] lengthBytes = new BigInteger(String.valueOf(newSymbol.getSize()-4), 10).toByteArray();
            Helper.reverse(lengthBytes);

            randomAccessFile.seek(originSymbol.offset+lengthOffset);
            randomAccessFile.write(lengthBytes);
            for(int i = 0; i < 4-lengthBytes.length; i++) {
                randomAccessFile.write((byte) 0);
            }
        }

        /*for (int i = 0; i < newSymbols.size(); i++) {
            int start = 0;
            if (i != 0) {
                start = newSymbols.get(i-1).offset + newSymbols.get(i-1).length;
            }
            int end = newSymbols.get(i).offset;
            assert start < end;
            protectionOffsets.add(new ProtectionOffset( start, textSection.addr + start, end - start));
        }*/
        protectionOffsets.add(textSection);
        // TODO: add protection for strings


        // Add integrity check and perform encryption
        List<IntegrityInfo> integrityInfos = Helper.readFile(integrityInfosFile, IntegrityInfo.class);
        for(IntegrityInfo integrityInfo : integrityInfos) {
            Symbol originSymbol = null;
            Symbol newSymbol = null;
            try {
                originSymbol = getSymbolFromList(symbols, integrityInfo.getSource_file(), integrityInfo.getOrigin_func());
                newSymbol = getSymbolFromList(symbols, integrityInfo.getSource_file(), integrityInfo.getNew_func());
            } catch (NoSuchElementException e) {
                System.err.println(e.getMessage());
                continue;
            }

            /*if (!originSymbol.name.contains("search_commands")) {
                continue;
            }*/

            // read new function bytes
            byte[] newFunctionBytes = new byte[newSymbol.length];
            randomAccessFile.seek(newSymbol.offset);
            randomAccessFile.read(newFunctionBytes);
            // String unsignedNewFunctionBytesString = Helper.getUnsignedBytesString(newFunctionBytes);

            for (int k = 0; k < 2; k++) {
                String unsignedNewFunctionBytesString = Helper.getUnsignedBytesString(newFunctionBytes);
                // System.out.println("unsigned string : " + unsignedNewFunctionBytesString);
                ProtectionOffset protectionOffset = protectionOffsets.get(new Random().nextInt(protectionOffsets.size()));

                byte tmp[] = new BigInteger(String.valueOf(integrityInfo.getTmp(k)[0])).toByteArray();
                Helper.reverse(tmp);
                String tmpstr = Helper.getUnsignedBytesString(tmp);
                int offsetOffset = (unsignedNewFunctionBytesString.indexOf(tmpstr) / 2);

                tmp = new BigInteger(String.valueOf(integrityInfo.getTmp(k)[1])).toByteArray();
                Helper.reverse(tmp);
                tmpstr = Helper.getUnsignedBytesString(tmp);
                int countOffset = (unsignedNewFunctionBytesString.indexOf(tmpstr) / 2);

                tmp = new BigInteger(String.valueOf(integrityInfo.getTmp(k)[2])).toByteArray();
                Helper.reverse(tmp);
                tmpstr = Helper.getUnsignedBytesString(tmp);
                int precomputedHashOffset = (unsignedNewFunctionBytesString.indexOf(tmpstr) / 2);
                assert countOffset == (offsetOffset-4) && offsetOffset == (precomputedHashOffset-4); // precomputedHashOffset == countOffset + 4 + 3;

                // read byte of the original function (for the AT control)
                // newSymbol.computeIntegrityCheckRange(newSymbols, elfBytes.length);

                byte[] integrityBytes = new byte[protectionOffset.size];
                randomAccessFile.seek(protectionOffset.offset);
                randomAccessFile.read(integrityBytes);
                long precomputedHash = integrityInfo.hashString(integrityBytes.clone());
                // System.out.println("Precomputed hash = " + precomputedHash + " with seed " + integrityInfo.getSeed() + " for " + integrityBytes.length + " bytes");

                String precomputedHashHexString = Long.toHexString(precomputedHash);
                assert precomputedHashHexString.length() == 8;

                // System.out.println(newSymbol.name + " --> precomputed string : " + precomputedHashHexString + " (from " + protectionOffset.addr + " - size " + protectionOffset.size + " - seed " + integrityInfo.getSeed() + ")");
                byte[] precomputedBytes = new BigInteger(precomputedHashHexString, 16).toByteArray();
                Helper.reverse(precomputedBytes);
                byte[] countBytes = new BigInteger(String.valueOf(protectionOffset.size), 10).toByteArray();
                Helper.reverse(countBytes);
                byte[] offsetBytes = new BigInteger(String.valueOf(protectionOffset.addr), 10).toByteArray();
                Helper.reverse(offsetBytes);

                // Replace the placeholder with the correct value
                for (int i = 0; i < 4; i++) {
                    try {
                        newFunctionBytes[i + offsetOffset] = offsetBytes[i];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        newFunctionBytes[i + offsetOffset] = (byte) 0;
                    }

                    try {
                        newFunctionBytes[i + countOffset] = countBytes[i];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        newFunctionBytes[i + countOffset] = (byte) 0;
                    }

                    try {
                        newFunctionBytes[i + precomputedHashOffset] = precomputedBytes[i];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        newFunctionBytes[i + precomputedHashOffset] = (byte) 0;
                    }
                }
            }

            // Encrypt the newFunctionBytes and rewrite to file
            byte[] encryptedBytes = integrityInfo.encryptBodyBytes(newFunctionBytes, newSymbol.getSize());
            randomAccessFile.seek(newSymbol.offset);
            randomAccessFile.write(encryptedBytes);

            // Remove current newSymbol from newSymbols list
            newSymbols.remove(newSymbol);
        }

        randomAccessFile.close();

        // Print general information
        StringBuilder stringBuilder = new StringBuilder(String.format("\n\n### Result Report ### \n"));
        stringBuilder.append(String.format("Number of protected function in elf : %d;\n", numberOfProtectedFunctionInElf));
        stringBuilder.append(String.format("Number of not founded symbols in elf : %d;\n", numberOfProtectedFunctionNotInElf));
        System.out.println(stringBuilder);
    }

    private static Symbol getSymbolFromList(List<Symbol> symbols, String sourceFile, String name){
        return symbols.stream()
                .filter(symbol -> name.equals(symbol.name) && sourceFile.equals(symbol.sourceFile))
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Symbol " + name + " not found"));
    }

    private static class ProtectionOffset {
        final int offset;
        final int addr;
        final int size;

        public ProtectionOffset(String line) {
            String split[] = line.trim().split("\\s+");
            this.addr = Integer.parseInt(split[4], 16);
            this.offset = Integer.parseInt(split[5], 16);
            this.size = Integer.parseInt(split[6], 16);
        }

        public ProtectionOffset(int offset, int addr, int size) {
            this.offset = offset;
            this.addr = addr;
            this.size = size;
        }
    }

}
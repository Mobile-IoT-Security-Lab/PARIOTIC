package main;

import java.io.*;
import java.math.BigInteger;
import java.util.*;
import models.*;
import org.apache.commons.cli.*;
import utils.Helper;

public class Main {

    private static Map<String, Object> parseArgv(String[] argv) {
        HelpFormatter formatter = new HelpFormatter();
        Map<String, Object> args = new HashMap<>();
        Options options = new Options();

        Option inputOption = new Option("i", "input", true, "The elf input file");
        inputOption.setRequired(true);
        options.addOption(inputOption);

        Option encryptionDetailsOption = new Option("ed", "encryption-details", true, "The encryption details file generated by the CLB Injector");
        encryptionDetailsOption.setRequired(true);
        options.addOption(encryptionDetailsOption);

        Option otherDetailsOption = new Option("od", "other-details", true, "The other details file generated by the CLB Injector");
        otherDetailsOption.setRequired(true);
        options.addOption(otherDetailsOption);

        // check for help
        if(Arrays.stream(argv).anyMatch("--help"::equals) || Arrays.stream(argv).anyMatch("-h"::equals)) {
            formatter.printHelp("utility-name", options);
            System.exit(0);
        }

        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = null;

        try {
            cmd = parser.parse(options, argv);
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            formatter.printHelp("CLB Protector", options);
            System.exit(1);
        }

        args.put("input", cmd.getOptionValue(inputOption.getOpt()));
        args.put("integrityInfosFile", cmd.getOptionValue(encryptionDetailsOption.getOpt()));
        args.put("hexPlaceholdersFile", cmd.getOptionValue(otherDetailsOption.getOpt()));

        return args;
    }

    public static void main(String[] argv) throws Exception {
        // parse args
        Map<String, Object> args = parseArgv(argv);
        String elf = (String) args.get("input");
        String integrityInfosFile = (String) args.get("integrityInfosFile");
        String hexPlaceholdersFile = (String) args.get("hexPlaceholdersFile");

        // Get symbol's information from nm linux command
        ProcessBuilder pb = new ProcessBuilder("nm", "-S", "-l", "--numeric-sort", "--defined-only", elf);
        Process p = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
        List<Symbol> symbols = new LinkedList<>();
        String encSymbolLine = null;
        while ((encSymbolLine = reader.readLine()) != null) {
            Symbol sym = null;
            try {
                sym = new Symbol(encSymbolLine);
            } catch (CustomException e) {
                System.err.println("Ignoring non source symbols");
                continue;
            }

            symbols.add(sym);
        }

        // Access to file with read and write permissions
        RandomAccessFile randomAccessFile = new RandomAccessFile(new File(elf), "rw");

        // Read elf bytes
        byte[] elfBytes = new byte[Math.toIntExact(randomAccessFile.length())];
        randomAccessFile.read(elfBytes);
        randomAccessFile.seek(0);

        int numberOfProtectedFunctionInElf = 0;
        int numberOfProtectedFunctionNotInElf = 0;

        List<Symbol> newSymbols = new ArrayList<>();

        // Substitute all values in original function -> We use them for the integrity check
        List<HexPlaceholder> hexPlaceholders = Helper.readFile(hexPlaceholdersFile, HexPlaceholder.class);
        for (HexPlaceholder hexPlaceholder : hexPlaceholders) {
            Symbol originSymbol = null;
            Symbol newSymbol = null;
            try {
                originSymbol = getSymbolFromList(symbols, hexPlaceholder.getSource_file(), hexPlaceholder.getOriginal_function_name());
                newSymbol = getSymbolFromList(symbols, hexPlaceholder.getSource_file(), hexPlaceholder.getNew_function_name());
                numberOfProtectedFunctionInElf++;
                newSymbols.add(newSymbol);
                newSymbols.sort(new Comparator<Symbol>() {
                    @Override
                    public int compare(Symbol s1, Symbol s2) {
                        return s1.offset - s2.offset;
                    }
                });
            } catch (NoSuchElementException e) {
                System.err.println(e.getMessage());
                numberOfProtectedFunctionNotInElf++;
                continue;
            }

            byte[] originFunctionBytes = new byte[originSymbol.length];
            randomAccessFile.seek(originSymbol.offset);
            randomAccessFile.read(originFunctionBytes);

            String unsignedOriginalBytesString = Helper.getUnsignedBytesString(originFunctionBytes);
            int lengthOffset = (unsignedOriginalBytesString.indexOf(hexPlaceholder.getHex_to_replace()) / 2);

            byte[] lengthBytes = new BigInteger(String.valueOf(newSymbol.length), 10).toByteArray();
            Helper.reverse(lengthBytes);

            randomAccessFile.seek(originSymbol.offset+lengthOffset);
            randomAccessFile.write(lengthBytes);
            for(int i = 0; i < 4-lengthBytes.length; i++) {
                randomAccessFile.write((byte) 0);
            }
        }

        List<IntegrityInfo> integrityInfos = Helper.readFile(integrityInfosFile, IntegrityInfo.class);
        for(IntegrityInfo integrityInfo : integrityInfos) {
            Symbol originSymbol = null;
            Symbol newSymbol = null;
            try {
                originSymbol = getSymbolFromList(symbols, integrityInfo.getSource_file(), integrityInfo.getOrigin_func());
                newSymbol = getSymbolFromList(symbols, integrityInfo.getSource_file(), integrityInfo.getNew_func());
            } catch (NoSuchElementException e) {
                System.err.println(e.getMessage());
                continue;
            }

            // read new function bytes
            byte[] newFunctionBytes = new byte[newSymbol.length];
            randomAccessFile.seek(newSymbol.offset);
            randomAccessFile.read(newFunctionBytes);
            String unsignedNewFunctionBytesString = Helper.getUnsignedBytesString(newFunctionBytes);

            // TODO: check and handle if there is more than one match
            int offsetOffset = (unsignedNewFunctionBytesString.indexOf("0137f50f") / 2);
            int countOffset = (unsignedNewFunctionBytesString.indexOf("10507eb1") / 2);
            int precomputedHashOffset = (unsignedNewFunctionBytesString.indexOf("ffff5945") / 2);
            assert precomputedHashOffset == countOffset + 4 + 3;

            // read byte of the original function (for the AT control)
            newSymbol.computeIntegrityCheckRange(newSymbols, elfBytes.length);

            byte[] integrityBytes = new byte[newSymbol.countOfIntegrityBytes];
            randomAccessFile.seek(newSymbol.startOffsetIntegrityCheck);
            randomAccessFile.read(integrityBytes);
            long precomputedHash = integrityInfo.hashString(integrityBytes.clone());
            // System.out.println("Precomputed hash = " + precomputedHash + " with seed " + integrityInfo.getSeed() + " for " + integrityBytes.length + " bytes");

            String precomputedHashHexString = Long.toHexString(precomputedHash);
            assert precomputedHashHexString.length() == 8;

            byte[] precomputedBytes =  new BigInteger(precomputedHashHexString, 16).toByteArray();
            Helper.reverse(precomputedBytes);
            byte[] countBytes = new BigInteger(String.valueOf(newSymbol.countOfIntegrityBytes), 10).toByteArray();
            Helper.reverse(countBytes);
            byte[] offsetBytes = new BigInteger(String.valueOf(newSymbol.startOffsetIntegrityCheck), 10).toByteArray();
            Helper.reverse(offsetBytes);

            // Replace the placeholder with the correct value
            for (int i = 0; i < 4; i++){
                try {
                    newFunctionBytes[i + offsetOffset] = offsetBytes[i];
                } catch (ArrayIndexOutOfBoundsException e) {
                    newFunctionBytes[i + offsetOffset] = (byte) 0;
                }

                try {
                    newFunctionBytes[i + countOffset] = countBytes[i];
                } catch (ArrayIndexOutOfBoundsException e) {
                    newFunctionBytes[i + countOffset] = (byte) 0;
                }

                try {
                    newFunctionBytes[i + precomputedHashOffset] = precomputedBytes[i];
                } catch (ArrayIndexOutOfBoundsException e) {
                    newFunctionBytes[i + precomputedHashOffset] = (byte) 0;
                }
            }

            // Encrypt the newFunctionBytes and rewrite to file
            byte[] encryptedBytes = integrityInfo.encryptBodyBytes(newFunctionBytes);
            randomAccessFile.seek(newSymbol.offset);
            randomAccessFile.write(encryptedBytes);

            // Remove current newSymbol from newSymbols list
            newSymbols.remove(newSymbol);
        }

        // Print general information
        StringBuilder stringBuilder = new StringBuilder(String.format("\n\n### Result Report ### \n"));
        stringBuilder.append(String.format("Number of protected function in elf : %d;\n", numberOfProtectedFunctionInElf));
        stringBuilder.append(String.format("Number of not founded symbols in elf : %d;\n", numberOfProtectedFunctionNotInElf));
        System.out.println(stringBuilder);
    }

    private static Symbol getSymbolFromList(List<Symbol> symbols, String sourceFile, String name){
        return symbols.stream()
                .filter(symbol -> name.equals(symbol.name) && sourceFile.equals(symbol.sourceFile))
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Symbol " + name + " not found"));
    }

}